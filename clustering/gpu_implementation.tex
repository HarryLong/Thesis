\section{GPU Implementation}

Performing K-Means clustering is an \textit{O(KN)} problem where K is the number of clusters. As a consequence, given a cluster count, the processing time will increase linearly with terrain area. For large terrains with millions of vertices this could prove time consuming and, consequentially, have a negative effect on user experience. To accelerate the clustering process and maximize user-experience it is implemented to make use of the heavily parallel architecture of the GPU. Below are discussed the details and optimizations of this implementation. \\

\begin{table}[]
  \centering
	    \begin{tabular}{|p{3cm}|p{1.5cm}|p{6cm}|p{5cm}|}
		\hline	
  	    \textbf{Storage Type} &  \textbf{Data Type} & \textbf{Element Count} & \textbf{Usage} \\
		\hline
		3-D Texture & Float & W $\times$ H $\times$ 12 & Monthly Soil Humidity \\
		\hline
		3-D Texture & Float & W $\times$ H $\times$ 12 & Monthly Illumination \\
		\hline
		2-D Texture & Float & W $\times$ H & Temperature \\
		\hline
		2-D Texture & Float & W $\times$ H & Slope \\
		\hline
		3-D Texture & Float & $ \textit{K} \times WorkGroups_{x} \times 13 \times WorkGroups_{y} $ &  Slope and Humidity Reducer \\
		\hline
		3-D Texture & Float & $ \textit{K} \times WorkGroups_{x} \times 2 \times WorkGroups_{y} $ &  Temperature Reducer \\
		\hline
		3-D Texture & Float & $ \textit{K} \times WorkGroups_{x} \times 12 \times WorkGroups_{y} $ & Daily Illumination Reducer \\
		\hline
		\end{tabular}
		\caption{Global memory allocations necessary for the GPU implementation of K-Means clustering. \textit{W} and \textit{H} are the width and height of the terrain respectively. \textit{WorkGroups$_{x}$} and \textit{WorkGroups$_{y}$} are the horizontal and vertical workgroup count respectively.}
	  \label{tab:clustering_mem_allocs}
\end{table}

\subsection{Calculating cluster membership}

Given the cluster means for iteration \textit{i}, the algorithm must determine to which cluster each terrain vertex belongs. To do so efficiently, each GPU core is associated a unique vertex and is responsible for determining it's cluster membership.

\subsection{Calculating the new cluster means}

Once all terrain vertices have been assigned to a cluster, they must be iterated over in order to calculate the new means of each cluster.\\

Within a work-group (group of cores which are guaranteed to run in parallel and have access to shared memory), when each core calculates it's distance from individual cluster means, it loads its associated resource data into a unique index of fast-access shared memory. It also stores in shared memory the calculated cluster membership. This data is then used to calculate, within each work-group, \textit{k} new work-group cluster means, in parallel. The \textit{k} work-group cluster means are then stored to global memory along with the member count for each cluster.\\

Finally, the global cluster means are calculated by \textit{k} cores in parallel using the means calculated for each individual work group along with their associated member counts.\\

\subsection{Storage Optimization}

The temperature on the terrain increases linearly with altitude. As such, even though the temperature changes monthly on the terrain, the temperature difference between two points \textit{P$_{a}$} and \textit{P$_{b}$} will remain constant throughout the year. Calculating the Euclidean distance from a given point \textit{A} to a cluster mean is identical to calculating the difference between two points on the terrain. As a consequence, it is only necessary to use a single months temperature data to establish terrain clusters, saving vital GPU storage space.

\subsection{Minimizing CPU to GPU data transfers}

As mentioned previously, copying data to and from CPU to GPU is a costly process. To prevent these costly transfer operations, all data required for the clustering algorithm (table \ref{tab:clustering_mem_allocs}) is copied to the GPU at the start of the clustering process and no further transfers are performed until completion. \\