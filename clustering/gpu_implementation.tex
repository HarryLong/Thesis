\section{GPU Implementation}

Performing K-Means clustering is an \textit{O(KN)} problem where K is the number of clusters. As a consequence, given a number of clusters \textit{K}, the processing time will increase linearly with the size of the terrain. For large terrains with millions of vertices, this would take time and, consequentially, have a negative effect on user experience. To accelerate the clustering process and improve user-experience it is implemented to make use of the heavily parallel architecture of the GPU.\\

As mentioned previously, copying data to/from CPU to/from GPU is a costly process. To prevent these costly transfer operations, all data required for the clustering algorithm (table \ref{tab:clustering_mem_allocs}) is copied to the GPU at the start of the clustering process and no further transfers are performed until completion. \\

\begin{table}[]
  \centering
	    \begin{tabular}{|p{3cm}|p{1.5cm}|p{6cm}|p{5cm}|}
		\hline	
  	    \textbf{Storage Type} &  \textbf{Data Type} & \textbf{Element Count} & \textbf{Usage} \\
		\hline
		3-D Texture & Float & W $\times$ H $\times$ 12 & Monthly Soil Humidity \\
		\hline
		3-D Texture & Float & W $\times$ H $\times$ 12 & Monthly Illumination \\
		\hline
		2-D Texture & Float & W $\times$ H & Temperature \\
		\hline
		2-D Texture & Float & W $\times$ H & Slope \\
		\hline
		3-D Texture & Float & $ \textit{K} \times WorkGroups_{x} \times 13 \times WorkGroups_{y} $ &  Slope and Humidity Reducer \\
		\hline
		3-D Texture & Float & $ \textit{K} \times WorkGroups_{x} \times 2 \times WorkGroups_{y} $ &  Temperature Reducer \\
		\hline
		3-D Texture & Float & $ \textit{K} \times WorkGroups_{x} \times 12 \times WorkGroups_{y} $ & Daily Illumination Reducer \\
		\hline
		\end{tabular}
		\caption{Global memory allocations necessary for the GPU implementation of K-Means clustering. \textit{W} and \textit{H} are the width and height of the terrain respectively. \textit{WorkGroups$_{x}$} and \textit{WorkGroups$_{y}$} are the horizontal and vertical workgroup count respectively.}
	  \label{tab:clustering_mem_allocs}
\end{table}

\subsection{Calculating cluster membership}

Given the cluster means for iteration \textit{i}, the process must determine to which cluster each terrain vertex belongs. The cluster membership of individual terrain vertices are calculated in parallel.

\subsection{Calculating the new cluster means}

Once all terrain vertices have been assigned to a cluster, the new cluster means need to be calculated. To do this, all terrain vertices must be processed in order to determine their cluster memberships and contribute to the new mean.\\

Parallelism is achieved by calculating the new means in parallel. Within a work group (group of cores which are guaranteed to run in parallel and have access to shared memory), when each core calculates it's distance from individual cluster means, it loads its associated resource data into a unique index of fast-access shared memory. It also stores in shared memory the calculated cluster membership. This data is then used to calculate within each work-group, \textit{k} new work group cluster means, \textit{ClusterMean$_{kxy}$}, in parallel. The \textit{k} work-group cluster means are then stored to global memory along with the member count for each cluster.\\

Finally, the global cluster means are calculated by \textit{k} cores in parallel using the work group cluster means and the associated member counts as weightings.\\

\subsection{Storage Optimization}

The temperature on the terrain increases linearly with altitude. As such, even though the temperature changes monthly on the terrain, the temperature difference between two points \textit{P$_{a}$} and \textit{P$_{b}$} will remain constant. Calculating the Euclidean distance from a given point \textit{A} to a cluster mean is identical to calculating the difference between two points on the terrain. As a consequence, it is only necessary to use a single months temperature data to establish terrain clusters, saving vital GPU storage space.

